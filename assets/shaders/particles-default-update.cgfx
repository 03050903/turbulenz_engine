#include "particles-common.cgh"

// Common to all updaters
// ----------------------
// textureSize, invTextureSize are defiend in particles-common
float timeStep;
float lifeStep;
float3 shift;
float3 halfExtents;

sampler2D previousState = sampler_state
{
    MinFilter = Nearest;
    MagFilter = Nearest;
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};
sampler2D creationState = sampler_state
{
    MinFilter = Nearest;
    MagFilter = Nearest;
    WrapS = ClampToEdge;
    WrapT = ClampToEdge;
};

// Specific to default updater
// --------------------------
float3 acceleration;
float drag;

sampler2D noiseTexture = sampler_state
{
    MinFilter = LinearMipMapNearest;
    magFilter = Linear;
    WrapS = Wrap;
    WrapT = Wrap;
};

// strength of randomisation
float3 randomizedAcceleration;

float3 getAccelerationNoise(float2 uv, float t)
{
    // constants are randomised values as are choice of noise channels.
    return (2.0 * tex2D(noiseTexture, uv + float2(0.97303011314943430, 0.19842534395866096) * t
                                         + float2(0.84200346702709790, 0.59638088289648291)).zyx - 1.0
           ) * randomizedAcceleration;
}

// --------------------------------------------------------------

float4 fp_update_state(float2 inParticle : TEXCOORD0) : COLOR
{
    float2 particle = inParticle * regionSize;
    float2 slot = getSlot(particle);
    bool create = createdParticle(creationState, particle, invRegionSize);

    if (slot.x <= 1)
    {
        // position
        float p = decodeSignedFloat(create ? tex2D(creationState, inParticle)
                                           : tex2D(previousState, particleRegionMap(inParticle)));
        float2 vt = inParticle + float2(1.0 * invRegionSize.x, 0);
        float v = decodeSignedFloat(create ? tex2D(creationState, vt)
                                           : tex2D(previousState, particleRegionMap(vt)));
        return encodeSignedFloat(p + (v * timeStep) + shift[slot.y]);
    }
    else if (slot.x <= 2)
    {
        // velocity
        float v = decodeSignedFloat(create ? tex2D(creationState, inParticle)
                                           : tex2D(previousState, particleRegionMap(inParticle)));

        float a = acceleration[slot.y];
        float2 pIndex = floor(particle / PARTICLE_DIM) * PARTICLE_DIM * invRegionSize;
        float4 data = create ? getData(creationState, pIndex, invRegionSize)
                             : getData(previousState, particleRegionMap(pIndex), invTextureSize);
        if (bitSet(data.w, BIT2))
        {
            float2 noiseUV = decodeUnsignedByteFloat2(data.z);

            float animTime = create ?
                  getAnimationTime(creationState, pIndex, invRegionSize,
                                    getLifePair(creationState, pIndex, invRegionSize))
                : getAnimationTime(previousState, particleRegionMap(pIndex), invTextureSize,
                                    getLifePair(previousState, particleRegionMap(pIndex), invTextureSize));

            a += getAccelerationNoise(noiseUV, animTime)[slot.y];
        }
        a /= halfExtents[slot.y];

        float d = 1.0 - min(1.0, timeStep * drag);
        return encodeSignedFloat(d * (v + a * timeStep));
    }
    else
    {
        if (slot.y <= 1)
        {
            // life
            float4 pix = create ? tex2D(creationState, inParticle)
                                : tex2D(previousState, particleRegionMap(inParticle));
            float life = decodeUnsignedHalf(pix.zw);
            return float4(pix.xy, encodeUnsignedHalf(life - lifeStep));
        }
        else
        {
            // user store.
            return create ? tex2D(creationState, inParticle)
                          : tex2D(previousState, particleRegionMap(inParticle));
        }
    }
}

// --------------------------------------------------------------

technique update_state
{
    pass
    {
        DepthTestEnable = false;
        DepthMask       = false;
        CullFaceEnable  = false;
        BlendEnable     = false;
        VertexProgram   = compile latest vp_update();
        FragmentProgram = compile latest fp_update_state();
    }
}

